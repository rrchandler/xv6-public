diff --git a/cat.c b/cat.c
index 8658a2f..5ddc820 100644
--- a/cat.c
+++ b/cat.c
@@ -12,14 +12,12 @@ cat(int fd)
   while((n = read(fd, buf, sizeof(buf))) > 0) {
     if (write(1, buf, n) != n) {
       printf(1, "cat: write error\n");
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
   if(n < 0){
     printf(1, "cat: read error\n");
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
 }
 
@@ -30,19 +28,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     }
     cat(fd);
     close(fd);
   }
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
diff --git a/defs.h b/defs.h
index 9e1ac50..82fb982 100644
--- a/defs.h
+++ b/defs.h
@@ -104,8 +104,7 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 int             cpuid(void);
-//Modified exit to accept a status
-void            exit(int status);
+void            exit(void);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -118,10 +117,9 @@ void            sched(void);
 void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(int *status);
+int             wait(void);
 void            wakeup(void*);
 void            yield(void);
-int             waitpid(int pid, int *status);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/echo.c b/echo.c
index 471e003..806dee0 100644
--- a/echo.c
+++ b/echo.c
@@ -9,6 +9,5 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
diff --git a/forktest.c b/forktest.c
index 737e096..8bc984d 100644
--- a/forktest.c
+++ b/forktest.c
@@ -25,36 +25,32 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      //Modified exit() call to pass in a 0, for error
-      exit(0);
+      exit();
   }
 
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(; n > 0; n--){
-    if(wait(0) < 0){
+    if(wait() < 0){
       printf(1, "wait stopped early\n");
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
 
-  if(wait(0) != -1){
+  if(wait() != -1){
     printf(1, "wait got too many\n");
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   printf(1, "fork test OK\n");
 }
 
-int main(void)
+int
+main(void)
 {
   forktest();
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
diff --git a/grep.c b/grep.c
index 0c48889..adc4835 100644
--- a/grep.c
+++ b/grep.c
@@ -43,28 +43,24 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
   pattern = argv[1];
 
   if(argc <= 2){
     grep(pattern, 0);
-    //Modified exit() call to pass in a 0, for no error
-    exit(0);
+    exit();
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     }
     grep(pattern, fd);
     close(fd);
   }
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/init.c b/init.c
index 2ca6574..046b551 100644
--- a/init.c
+++ b/init.c
@@ -24,16 +24,14 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     }
-    while((wpid=wait(0)) >= 0 && wpid != pid)
+    while((wpid=wait()) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/kill.c b/kill.c
index c2d5ba7..364f6af 100644
--- a/kill.c
+++ b/kill.c
@@ -9,11 +9,9 @@ main(int argc, char **argv)
 
   if(argc < 2){
     printf(2, "usage: kill pid...\n");
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
diff --git a/ln.c b/ln.c
index 55c367a..cf8a64e 100644
--- a/ln.c
+++ b/ln.c
@@ -7,11 +7,9 @@ main(int argc, char *argv[])
 {
   if(argc != 3){
     printf(2, "Usage: ln old new\n");
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-    //Modified exit() call to pass in a 0, for error
-  exit(0);
+  exit();
 }
diff --git a/ls.c b/ls.c
index c4c6c27..2862913 100644
--- a/ls.c
+++ b/ls.c
@@ -77,11 +77,9 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     ls(".");
-    //Modified exit() call to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   for(i=1; i<argc; i++)
     ls(argv[i]);
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
diff --git a/mkdir.c b/mkdir.c
index c920be5..6e4c954 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -9,8 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
@@ -19,6 +18,6 @@ main(int argc, char *argv[])
       break;
     }
   }
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+
+  exit();
 }
diff --git a/proc.c b/proc.c
index 26d7875..806b1b1 100644
--- a/proc.c
+++ b/proc.c
@@ -224,7 +224,8 @@ fork(void)
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void exit(int status)
+void
+exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
@@ -247,7 +248,7 @@ void exit(int status)
   curproc->cwd = 0;
 
   acquire(&ptable.lock);
-  curproc->exitStatus = status;
+
   // Parent might be sleeping in wait().
   wakeup1(curproc->parent);
 
@@ -268,7 +269,9 @@ void exit(int status)
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int wait(int *status) {
+int
+wait(void)
+{
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
@@ -284,10 +287,6 @@ int wait(int *status) {
       if(p->state == ZOMBIE){
         // Found one.
         pid = p->pid;
-        //Added way to return/store exit status if not null
-        if(status != 0) {
-          *status = p->exitStatus;
-        }
         kfree(p->kstack);
         p->kstack = 0;
         freevm(p->pgdir);
@@ -320,7 +319,8 @@ int wait(int *status) {
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
-void scheduler(void)
+void
+scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
@@ -362,7 +362,8 @@ void scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void sched(void)
+void
+sched(void)
 {
   int intena;
   struct proc *p = myproc();
@@ -381,7 +382,8 @@ void sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void yield(void)
+void
+yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
   myproc()->state = RUNNABLE;
@@ -391,7 +393,8 @@ void yield(void)
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void forkret(void)
+void
+forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
@@ -411,7 +414,8 @@ void forkret(void)
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void sleep(void *chan, struct spinlock *lk)
+void
+sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
   
@@ -450,7 +454,8 @@ void sleep(void *chan, struct spinlock *lk)
 //PAGEBREAK!
 // Wake up all processes sleeping on chan.
 // The ptable lock must be held.
-static void wakeup1(void *chan)
+static void
+wakeup1(void *chan)
 {
   struct proc *p;
 
@@ -460,7 +465,8 @@ static void wakeup1(void *chan)
 }
 
 // Wake up all processes sleeping on chan.
-void wakeup(void *chan)
+void
+wakeup(void *chan)
 {
   acquire(&ptable.lock);
   wakeup1(chan);
@@ -470,7 +476,8 @@ void wakeup(void *chan)
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int kill(int pid)
+int
+kill(int pid)
 {
   struct proc *p;
 
@@ -493,7 +500,8 @@ int kill(int pid)
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void procdump(void)
+void
+procdump(void)
 {
   static char *states[] = {
   [UNUSED]    "unused",
@@ -524,43 +532,3 @@ void procdump(void)
     cprintf("\n");
   }
 }
-
-int waitpid(int pid, int *status) {
-  struct proc *p;
-  struct proc *curproc = myproc();
-  unsigned char flag = 0;
-  
-  acquire(&ptable.lock);
-  for(;;){
-    // Scan through table looking for exited children.
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->pid == pid) {
-        flag = 1;
-        if(p->state == ZOMBIE){
-          //Added way to return/store exit status if not null
-         if(status != 0) {
-          *status = p->exitStatus;
-          }
-          kfree(p->kstack);
-          p->kstack = 0;
-          freevm(p->pgdir);
-          p->pid = 0;
-          p->parent = 0;
-          p->name[0] = 0;
-          p->killed = 0;
-          p->state = UNUSED;
-          release(&ptable.lock);
-          return pid;
-        }
-      }
-    }
-
-    if(flag == 0 || curproc->killed) {
-      release(&ptable.lock);
-      return -1;
-    }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-  }
-}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index d7b4a28..1647114 100644
--- a/proc.h
+++ b/proc.h
@@ -49,7 +49,6 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
-  int exitStatus;              // Storing exit status for lab1
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/rm.c b/rm.c
index d3fdf57..4fd33c8 100644
--- a/rm.c
+++ b/rm.c
@@ -2,14 +2,14 @@
 #include "stat.h"
 #include "user.h"
 
-int main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
   int i;
 
   if(argc < 2){
     printf(2, "Usage: rm files...\n");
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
@@ -18,6 +18,6 @@ int main(int argc, char *argv[])
       break;
     }
   }
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+
+  exit();
 }
diff --git a/sh.c b/sh.c
index a9b227a..054bab9 100644
--- a/sh.c
+++ b/sh.c
@@ -65,8 +65,7 @@ runcmd(struct cmd *cmd)
   struct redircmd *rcmd;
 
   if(cmd == 0)
-    //Modified exit() call to pass in a 0, for no error
-    exit(0);
+    exit();
 
   switch(cmd->type){
   default:
@@ -75,8 +74,7 @@ runcmd(struct cmd *cmd)
   case EXEC:
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
@@ -86,8 +84,7 @@ runcmd(struct cmd *cmd)
     close(rcmd->fd);
     if(open(rcmd->file, rcmd->mode) < 0){
       printf(2, "open %s failed\n", rcmd->file);
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
+      exit();
     }
     runcmd(rcmd->cmd);
     break;
@@ -96,7 +93,7 @@ runcmd(struct cmd *cmd)
     lcmd = (struct listcmd*)cmd;
     if(fork1() == 0)
       runcmd(lcmd->left);
-    wait(0);
+    wait();
     runcmd(lcmd->right);
     break;
 
@@ -120,8 +117,8 @@ runcmd(struct cmd *cmd)
     }
     close(p[0]);
     close(p[1]);
-    wait(0);
-    wait(0);
+    wait();
+    wait();
     break;
 
   case BACK:
@@ -130,8 +127,7 @@ runcmd(struct cmd *cmd)
       runcmd(bcmd->cmd);
     break;
   }
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
 
 int
@@ -170,18 +166,16 @@ main(void)
     }
     if(fork1() == 0)
       runcmd(parsecmd(buf));
-    wait(0);
+    wait();
   }
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
 
 void
 panic(char *s)
 {
   printf(2, "%s\n", s);
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  exit();
 }
 
 int
diff --git a/stressfs.c b/stressfs.c
index b86908c..c0a4743 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -13,7 +13,8 @@
 #include "fs.h"
 #include "fcntl.h"
 
-int main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
   int fd, i;
   char path[] = "stressfs0";
@@ -42,7 +43,7 @@ int main(int argc, char *argv[])
     read(fd, data, sizeof(data));
   close(fd);
 
-  wait(0);
-  //Modified exit() call to pass in a 0, for no error
-  exit(0);
+  wait();
+
+  exit();
 }
diff --git a/syscall.c b/syscall.c
index 4f6a4be..ee85261 100644
--- a/syscall.c
+++ b/syscall.c
@@ -46,7 +46,8 @@ fetchstr(uint addr, char **pp)
 }
 
 // Fetch the nth 32-bit system call argument.
-int argint(int n, int *ip)
+int
+argint(int n, int *ip)
 {
   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
 }
@@ -54,7 +55,8 @@ int argint(int n, int *ip)
 // Fetch the nth word-sized system call argument as a pointer
 // to a block of memory of size bytes.  Check that the pointer
 // lies within the process address space.
-int argptr(int n, char **pp, int size)
+int
+argptr(int n, char **pp, int size)
 {
   int i;
   struct proc *curproc = myproc();
@@ -71,7 +73,8 @@ int argptr(int n, char **pp, int size)
 // Check that the pointer is valid and the string is nul-terminated.
 // (There is no shared writable memory, so the string can't change
 // between this check and being used by the kernel.)
-int argstr(int n, char **pp)
+int
+argstr(int n, char **pp)
 {
   int addr;
   if(argint(n, &addr) < 0)
@@ -100,7 +103,6 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
-extern int sys_waitpid(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -124,7 +126,6 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
-[SYS_waitpid] sys_waitpid,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index eda417c..bc5f356 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,4 +20,3 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
-#define SYS_waitpid 22
diff --git a/sysproc.c b/sysproc.c
index bdcd5f1..0686d29 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -13,24 +13,17 @@ sys_fork(void)
   return fork();
 }
 
-// Modified sys_exit() to generate a status int
-int sys_exit()
+int
+sys_exit(void)
 {
-  int status;
-
-  if(argint(0, &status) < 0)
-    return -1;
-  exit(status);
+  exit();
   return 0;  // not reached
 }
 
-int sys_wait(void)
+int
+sys_wait(void)
 {
-  int *status;
-  if (argptr(0, (void*)&status, sizeof(int)) < 0) {
-    return -1;
-  }
-  return wait(status);
+  return wait();
 }
 
 int
@@ -96,13 +89,3 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
-
-//Added waitpid
-int sys_waitpid(void) {
-  int pid;
-  int *status;
-  if (argint(0, &pid)<0 || argptr(1, (void*)&status, sizeof(int)) < 0)
-    return -1;
-  else
-    return waitpid(pid, status);
-}
\ No newline at end of file
diff --git a/trap.c b/trap.c
index 4728432..41c66eb 100644
--- a/trap.c
+++ b/trap.c
@@ -37,16 +37,12 @@ void
 trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
-    if(myproc()->killed){
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
-    }
+    if(myproc()->killed)
+      exit();
     myproc()->tf = tf;
     syscall();
-    if(myproc()->killed){
-      //Modified exit() call to pass in a 1, for error
-      exit(1);
-    }
+    if(myproc()->killed)
+      exit();
     return;
   }
 
@@ -101,10 +97,9 @@ trap(struct trapframe *tf)
   // Force process exit if it has been killed and is in user space.
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER) {
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
-  }
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+    exit();
+
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
   if(myproc() && myproc()->state == RUNNING &&
@@ -112,8 +107,6 @@ trap(struct trapframe *tf)
     yield();
 
   // Check if the process has been killed since we yielded
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)  {
-    //Modified exit() call to pass in a 1, for error
-    exit(1);
-  }
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+    exit();
 }
diff --git a/user.h b/user.h
index 5505818..4f99c52 100644
--- a/user.h
+++ b/user.h
@@ -3,10 +3,8 @@ struct rtcdate;
 
 // system calls
 int fork(void);
-// Modified exit() to be void and accept an int
-void exit(int status) __attribute__((noreturn));
-//modified wait() to accept exit status
-int wait(int *status);
+int exit(void) __attribute__((noreturn));
+int wait(void);
 int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
@@ -25,8 +23,6 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
-int waitpid(int pid, int *status);
-
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usertests.c b/usertests.c
index 00f2240..a1e97e7 100644
--- a/usertests.c
+++ b/usertests.c
@@ -21,29 +21,26 @@ iputtest(void)
 
   if(mkdir("iputdir") < 0){
     printf(stdout, "mkdir failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(chdir("iputdir") < 0){
     printf(stdout, "chdir iputdir failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink("../iputdir") < 0){
     printf(stdout, "unlink ../iputdir failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(chdir("/") < 0){
     printf(stdout, "chdir / failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   printf(stdout, "iput test ok\n");
 }
 
 // does exit() call iput(p->cwd) in a transaction?
-void exitiputtest(void)
+void
+exitiputtest(void)
 {
   int pid;
 
@@ -52,29 +49,24 @@ void exitiputtest(void)
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(pid == 0){
     if(mkdir("iputdir") < 0){
       printf(stdout, "mkdir failed\n");
-      //modified exit() to pass in a 1, for error
-    exit(1);
+      exit();
     }
     if(chdir("iputdir") < 0){
       printf(stdout, "child chdir failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(unlink("../iputdir") < 0){
       printf(stdout, "unlink ../iputdir failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
-    //modified exit() to pass in a 0, for no error
-    exit(1);
+    exit();
   }
-  wait(0);
+  wait();
   printf(stdout, "exitiput test ok\n");
 }
 
@@ -97,32 +89,27 @@ openiputtest(void)
   printf(stdout, "openiput test\n");
   if(mkdir("oidir") < 0){
     printf(stdout, "mkdir oidir failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(pid == 0){
     int fd = open("oidir", O_RDWR);
     if(fd >= 0){
       printf(stdout, "open directory for write succeeded\n");
-      //modified exit() to pass in a 0, for no error
-      exit(0);
+      exit();
     }
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   sleep(1);
   if(unlink("oidir") != 0){
     printf(stdout, "unlink failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
-  wait(0);
+  wait();
   printf(stdout, "openiput test ok\n");
 }
 
@@ -137,15 +124,13 @@ opentest(void)
   fd = open("echo", 0);
   if(fd < 0){
     printf(stdout, "open echo failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
   fd = open("doesnotexist", 0);
   if(fd >= 0){
     printf(stdout, "open doesnotexist succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   printf(stdout, "open test ok\n");
 }
@@ -162,19 +147,16 @@ writetest(void)
     printf(stdout, "creat small succeeded; ok\n");
   } else {
     printf(stdout, "error: creat small failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   for(i = 0; i < 100; i++){
     if(write(fd, "aaaaaaaaaa", 10) != 10){
       printf(stdout, "error: write aa %d new file failed\n", i);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(write(fd, "bbbbbbbbbb", 10) != 10){
       printf(stdout, "error: write bb %d new file failed\n", i);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
   printf(stdout, "writes ok\n");
@@ -184,23 +166,20 @@ writetest(void)
     printf(stdout, "open small succeeded ok\n");
   } else {
     printf(stdout, "error: open small failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   i = read(fd, buf, 2000);
   if(i == 2000){
     printf(stdout, "read succeeded ok\n");
   } else {
     printf(stdout, "read failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
 
   if(unlink("small") < 0){
     printf(stdout, "unlink small failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   printf(stdout, "small file test ok\n");
 }
@@ -215,16 +194,14 @@ writetest1(void)
   fd = open("big", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(stdout, "error: creat big failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(i = 0; i < MAXFILE; i++){
     ((int*)buf)[0] = i;
     if(write(fd, buf, 512) != 512){
       printf(stdout, "error: write big file failed\n", i);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
 
@@ -233,8 +210,7 @@ writetest1(void)
   fd = open("big", O_RDONLY);
   if(fd < 0){
     printf(stdout, "error: open big failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   n = 0;
@@ -243,28 +219,24 @@ writetest1(void)
     if(i == 0){
       if(n == MAXFILE - 1){
         printf(stdout, "read only %d blocks from big", n);
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       }
       break;
     } else if(i != 512){
       printf(stdout, "read failed %d\n", i);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(((int*)buf)[0] != n){
       printf(stdout, "read content of block %d is %d\n",
              n, ((int*)buf)[0]);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     n++;
   }
   close(fd);
   if(unlink("big") < 0){
     printf(stdout, "unlink big failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   printf(stdout, "big files ok\n");
 }
@@ -298,26 +270,22 @@ void dirtest(void)
 
   if(mkdir("dir0") < 0){
     printf(stdout, "mkdir failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   if(chdir("dir0") < 0){
     printf(stdout, "chdir dir0 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   if(chdir("..") < 0){
     printf(stdout, "chdir .. failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   if(unlink("dir0") < 0){
     printf(stdout, "unlink dir0 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   printf(stdout, "mkdir test ok\n");
 }
@@ -328,8 +296,7 @@ exectest(void)
   printf(stdout, "exec test\n");
   if(exec("echo", echoargv) < 0){
     printf(stdout, "exec echo failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 }
 
@@ -343,8 +310,7 @@ pipe1(void)
 
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   pid = fork();
   seq = 0;
@@ -355,12 +321,10 @@ pipe1(void)
         buf[i] = seq++;
       if(write(fds[1], buf, 1033) != 1033){
         printf(1, "pipe1 oops 1\n");
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       }
     }
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   } else if(pid > 0){
     close(fds[1]);
     total = 0;
@@ -379,15 +343,13 @@ pipe1(void)
     }
     if(total != 5 * 1033){
       printf(1, "pipe1 oops 3 total %d\n", total);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     close(fds[0]);
-    wait(0);
+    wait();
   } else {
     printf(1, "fork() failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   printf(1, "pipe1 ok\n");
 }
@@ -432,9 +394,9 @@ preempt(void)
   kill(pid2);
   kill(pid3);
   printf(1, "wait... ");
-  wait(0);
-  wait(0);
-  wait(0);
+  wait();
+  wait();
+  wait();
   printf(1, "preempt ok\n");
 }
 
@@ -451,13 +413,12 @@ exitwait(void)
       return;
     }
     if(pid){
-      if(wait(0) != pid){
+      if(wait() != pid){
         printf(1, "wait wrong pid\n");
         return;
       }
     } else {
-      //modified exit() to pass in a 0, for no error
-      exit(0);
+      exit();
     }
   }
   printf(1, "exitwait ok\n");
@@ -486,15 +447,13 @@ mem(void)
     if(m1 == 0){
       printf(1, "couldn't allocate mem?!!\n");
       kill(ppid);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     free(m1);
     printf(1, "mem ok\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   } else {
-    wait(0);
+    wait();
   }
 }
 
@@ -525,10 +484,9 @@ sharedfd(void)
     }
   }
   if(pid == 0)
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   else
-    wait(0);
+    wait();
   close(fd);
   fd = open("sharedfd", 0);
   if(fd < 0){
@@ -550,8 +508,7 @@ sharedfd(void)
     printf(1, "sharedfd ok\n");
   } else {
     printf(1, "sharedfd oops %d %d\n", nc, np);
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 }
 
@@ -573,33 +530,29 @@ fourfiles(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
 
     if(pid == 0){
       fd = open(fname, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "create failed\n");
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       }
 
       memset(buf, '0'+pi, 512);
       for(i = 0; i < 12; i++){
         if((n = write(fd, buf, 500)) != 500){
           printf(1, "write failed %d\n", n);
-          //modified exit() to pass in a 1, for error
-          exit(1);
+          exit();
         }
       }
-      //modified exit() to pass in a 0, for no error
-      exit(0);
+      exit();
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait(0);
+    wait();
   }
 
   for(i = 0; i < 2; i++){
@@ -610,8 +563,7 @@ fourfiles(void)
       for(j = 0; j < n; j++){
         if(buf[j] != '0'+i){
           printf(1, "wrong char\n");
-          //modified exit() to pass in a 1, for error
-          exit(1);
+          exit();
         }
       }
       total += n;
@@ -619,8 +571,7 @@ fourfiles(void)
     close(fd);
     if(total != 12*500){
       printf(1, "wrong length %d\n", total);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     unlink(fname);
   }
@@ -642,8 +593,7 @@ createdelete(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
 
     if(pid == 0){
@@ -654,26 +604,23 @@ createdelete(void)
         fd = open(name, O_CREATE | O_RDWR);
         if(fd < 0){
           printf(1, "create failed\n");
-        //modified exit() to pass in a 1, for error
-        exit(1);
+          exit();
         }
         close(fd);
         if(i > 0 && (i % 2 ) == 0){
           name[1] = '0' + (i / 2);
           if(unlink(name) < 0){
             printf(1, "unlink failed\n");
-            //modified exit() to pass in a 1, for error
-            exit(1);
+            exit();
           }
         }
       }
-      //modified exit() to pass in a 0, for error
-      exit(0);
+      exit();
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait(0);
+    wait();
   }
 
   name[0] = name[1] = name[2] = 0;
@@ -684,12 +631,10 @@ createdelete(void)
       fd = open(name, 0);
       if((i == 0 || i >= N/2) && fd < 0){
         printf(1, "oops createdelete %s didn't exist\n", name);
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       } else if((i >= 1 && i < N/2) && fd >= 0){
         printf(1, "oops createdelete %s did exist\n", name);
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       }
       if(fd >= 0)
         close(fd);
@@ -708,7 +653,8 @@ createdelete(void)
 }
 
 // can I unlink a file and still read it?
-void unlinkread(void)
+void
+unlinkread(void)
 {
   int fd, fd1;
 
@@ -716,8 +662,7 @@ void unlinkread(void)
   fd = open("unlinkread", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create unlinkread failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   write(fd, "hello", 5);
   close(fd);
@@ -725,13 +670,11 @@ void unlinkread(void)
   fd = open("unlinkread", O_RDWR);
   if(fd < 0){
     printf(1, "open unlinkread failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink("unlinkread") != 0){
     printf(1, "unlink unlinkread failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   fd1 = open("unlinkread", O_CREATE | O_RDWR);
@@ -740,18 +683,15 @@ void unlinkread(void)
 
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "unlinkread read failed");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(buf[0] != 'h'){
     printf(1, "unlinkread wrong data\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(write(fd, buf, 10) != 10){
     printf(1, "unlinkread write failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
   unlink("unlinkread");
@@ -771,59 +711,50 @@ linktest(void)
   fd = open("lf1", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(1, "create lf1 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(write(fd, "hello", 5) != 5){
     printf(1, "write lf1 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
 
   if(link("lf1", "lf2") < 0){
     printf(1, "link lf1 lf2 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   unlink("lf1");
 
   if(open("lf1", 0) >= 0){
     printf(1, "unlinked lf1 but it is still there!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   fd = open("lf2", 0);
   if(fd < 0){
     printf(1, "open lf2 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "read lf2 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
 
   if(link("lf2", "lf2") >= 0){
     printf(1, "link lf2 lf2 succeeded! oops\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   unlink("lf2");
   if(link("lf2", "lf1") >= 0){
     printf(1, "link non-existant succeeded! oops\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   if(link(".", "lf1") >= 0){
     printf(1, "link . lf1 succeeded! oops\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   printf(1, "linktest ok\n");
@@ -856,16 +787,14 @@ concreate(void)
       fd = open(file, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "concreate create %s failed\n", file);
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       }
       close(fd);
     }
     if(pid == 0)
-      //modified exit() to pass in a 0, for no error
-      exit(0);
+      exit();
     else
-      wait(0);
+      wait();
   }
 
   memset(fa, 0, sizeof(fa));
@@ -878,13 +807,11 @@ concreate(void)
       i = de.name[1] - '0';
       if(i < 0 || i >= sizeof(fa)){
         printf(1, "concreate weird file %s\n", de.name);
-        //modified exit() to pass in a 1, for error
-         exit(1);
+        exit();
       }
       if(fa[i]){
         printf(1, "concreate duplicate file %s\n", de.name);
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       }
       fa[i] = 1;
       n++;
@@ -894,8 +821,7 @@ concreate(void)
 
   if(n != 40){
     printf(1, "concreate not enough files in directory listing\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(i = 0; i < 40; i++){
@@ -903,8 +829,7 @@ concreate(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(((i % 3) == 0 && pid == 0) ||
        ((i % 3) == 1 && pid != 0)){
@@ -919,10 +844,9 @@ concreate(void)
       unlink(file);
     }
     if(pid == 0)
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     else
-      wait(0);
+      wait();
   }
 
   printf(1, "concreate ok\n");
@@ -941,8 +865,7 @@ linkunlink()
   pid = fork();
   if(pid < 0){
     printf(1, "fork failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   unsigned int x = (pid ? 1 : 97);
@@ -958,10 +881,9 @@ linkunlink()
   }
 
   if(pid)
-    wait(0);
+    wait();
   else
-    //modified exit() to pass in a 0, for error
-    exit(0);
+    exit();
 
   printf(1, "linkunlink ok\n");
 }
@@ -979,8 +901,7 @@ bigdir(void)
   fd = open("bd", O_CREATE);
   if(fd < 0){
     printf(1, "bigdir create failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
 
@@ -991,8 +912,7 @@ bigdir(void)
     name[3] = '\0';
     if(link("bd", name) != 0){
       printf(1, "bigdir link failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
 
@@ -1004,8 +924,7 @@ bigdir(void)
     name[3] = '\0';
     if(unlink(name) != 0){
       printf(1, "bigdir unlink failed");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
 
@@ -1022,36 +941,31 @@ subdir(void)
   unlink("ff");
   if(mkdir("dd") != 0){
     printf(1, "subdir mkdir dd failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   fd = open("dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/ff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   write(fd, "ff", 2);
   close(fd);
 
   if(unlink("dd") >= 0){
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
 
   if(mkdir("/dd/dd") != 0){
     printf(1, "subdir mkdir dd/dd failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/dd/ff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   write(fd, "FF", 2);
   close(fd);
@@ -1059,174 +973,142 @@ subdir(void)
   fd = open("dd/dd/../ff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/../ff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   cc = read(fd, buf, sizeof(buf));
   if(cc != 2 || buf[0] != 'f'){
     printf(1, "dd/dd/../ff wrong content\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
 
   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   if(unlink("dd/dd/ff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   if(chdir("dd") != 0){
     printf(1, "chdir dd failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(chdir("dd/../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(chdir("dd/../../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(chdir("./..") != 0){
     printf(1, "chdir ./.. failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   fd = open("dd/dd/ffff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/ffff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(read(fd, buf, sizeof(buf)) != 2){
     printf(1, "read dd/dd/ffff wrong len\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
 
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
 
   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/ff/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/xx/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(open("dd", O_CREATE) >= 0){
     printf(1, "create dd succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(open("dd", O_RDWR) >= 0){
     printf(1, "open dd rdwr succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(open("dd", O_WRONLY) >= 0){
     printf(1, "open dd wronly succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(link("dd/ff/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(link("dd/xx/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(link("dd/ff", "dd/dd/ffff") == 0){
     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(mkdir("dd/ff/ff") == 0){
     printf(1, "mkdir dd/ff/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(mkdir("dd/xx/ff") == 0){
     printf(1, "mkdir dd/xx/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(mkdir("dd/dd/ffff") == 0){
     printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(unlink("dd/xx/ff") == 0){
     printf(1, "unlink dd/xx/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(unlink("dd/ff/ff") == 0){
     printf(1, "unlink dd/ff/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(chdir("dd/ff") == 0){
     printf(1, "chdir dd/ff succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(chdir("dd/xx") == 0){
     printf(1, "chdir dd/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
 
   if(unlink("dd/dd/ffff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink("dd/ff") != 0){
     printf(1, "unlink dd/ff failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink("dd") == 0){
     printf(1, "unlink non-empty dd succeeded!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink("dd/dd") < 0){
     printf(1, "unlink dd/dd failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink("dd") < 0){
     printf(1, "unlink dd failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   printf(1, "subdir ok\n");
@@ -1245,16 +1127,14 @@ bigwrite(void)
     fd = open("bigwrite", O_CREATE | O_RDWR);
     if(fd < 0){
       printf(1, "cannot create bigwrite\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     int i;
     for(i = 0; i < 2; i++){
       int cc = write(fd, buf, sz);
       if(cc != sz){
         printf(1, "write(%d) ret %d\n", sz, cc);
-        //modified exit() to pass in a 1, for error
-        exit(1);
+        exit();
       }
     }
     close(fd);
@@ -1275,15 +1155,13 @@ bigfile(void)
   fd = open("bigfile", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "cannot create bigfile");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   for(i = 0; i < 20; i++){
     memset(buf, i, 600);
     if(write(fd, buf, 600) != 600){
       printf(1, "write bigfile failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
   close(fd);
@@ -1291,36 +1169,31 @@ bigfile(void)
   fd = open("bigfile", 0);
   if(fd < 0){
     printf(1, "cannot open bigfile\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   total = 0;
   for(i = 0; ; i++){
     cc = read(fd, buf, 300);
     if(cc < 0){
       printf(1, "read bigfile failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(cc == 0)
       break;
     if(cc != 300){
       printf(1, "short read bigfile\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(buf[0] != i/2 || buf[299] != i/2){
       printf(1, "read bigfile wrong data\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     total += cc;
   }
   close(fd);
   if(total != 20*600){
     printf(1, "read bigfile wrong total\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   unlink("bigfile");
 
@@ -1337,38 +1210,32 @@ fourteen(void)
 
   if(mkdir("12345678901234") != 0){
     printf(1, "mkdir 12345678901234 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(mkdir("12345678901234/123456789012345") != 0){
     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
   if(fd < 0){
     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
   fd = open("12345678901234/12345678901234/12345678901234", 0);
   if(fd < 0){
     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
 
   if(mkdir("12345678901234/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(mkdir("123456789012345/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
 
   printf(1, "fourteen ok\n");
@@ -1380,43 +1247,35 @@ rmdot(void)
   printf(1, "rmdot test\n");
   if(mkdir("dots") != 0){
     printf(1, "mkdir dots failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(chdir("dots") != 0){
     printf(1, "chdir dots failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink(".") == 0){
     printf(1, "rm . worked!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(unlink("..") == 0){
     printf(1, "rm .. worked!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(chdir("/") != 0){
     printf(1, "chdir / failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(unlink("dots/.") == 0){
     printf(1, "unlink dots/. worked!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(unlink("dots/..") == 0){
     printf(1, "unlink dots/.. worked!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(unlink("dots") != 0){
     printf(1, "unlink dots failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   printf(1, "rmdot ok\n");
 }
@@ -1431,59 +1290,49 @@ dirfile(void)
   fd = open("dirfile", O_CREATE);
   if(fd < 0){
     printf(1, "create dirfile failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
   if(chdir("dirfile") == 0){
     printf(1, "chdir dirfile succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   fd = open("dirfile/xx", 0);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   fd = open("dirfile/xx", O_CREATE);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(mkdir("dirfile/xx") == 0){
     printf(1, "mkdir dirfile/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(unlink("dirfile/xx") == 0){
     printf(1, "unlink dirfile/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(link("README", "dirfile/xx") == 0){
     printf(1, "link to dirfile/xx succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   if(unlink("dirfile") != 0){
     printf(1, "unlink dirfile failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   fd = open(".", O_RDWR);
   if(fd >= 0){
     printf(1, "open . for writing succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   fd = open(".", 0);
   if(write(fd, "x", 1) > 0){
     printf(1, "write . succeeded!\n");
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   }
   close(fd);
 
@@ -1502,13 +1351,11 @@ iref(void)
   for(i = 0; i < 50 + 1; i++){
     if(mkdir("irefd") != 0){
       printf(1, "mkdir irefd failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(chdir("irefd") != 0){
       printf(1, "chdir irefd failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
 
     mkdir("");
@@ -1541,28 +1388,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
   }
 
   if(n == 1000){
     printf(1, "fork claimed to work 1000 times!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(; n > 0; n--){
-    if(wait(0) < 0){
+    if(wait() < 0){
       printf(1, "wait stopped early\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
 
-  if(wait(0) != -1){
+  if(wait() != -1){
     printf(1, "wait got too many\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   printf(1, "fork test OK\n");
@@ -1585,8 +1428,7 @@ sbrktest(void)
     b = sbrk(1);
     if(b != a){
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     *b = 1;
     a = b + 1;
@@ -1594,20 +1436,17 @@ sbrktest(void)
   pid = fork();
   if(pid < 0){
     printf(stdout, "sbrk test fork failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   c = sbrk(1);
   c = sbrk(1);
   if(c != a + 1){
     printf(stdout, "sbrk test failed post-fork\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(pid == 0)
-    //modified exit() to pass in a 0, for no error
-    exit(0);
-  wait(0);
+    exit();
+  wait();
 
   // can one grow address space to something big?
 #define BIG (100*1024*1024)
@@ -1616,8 +1455,7 @@ sbrktest(void)
   p = sbrk(amt);
   if (p != a) {
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   lastaddr = (char*) (BIG-1);
   *lastaddr = 99;
@@ -1627,14 +1465,12 @@ sbrktest(void)
   c = sbrk(-4096);
   if(c == (char*)0xffffffff){
     printf(stdout, "sbrk could not deallocate\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   c = sbrk(0);
   if(c != a - 4096){
     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   // can one re-allocate that page?
@@ -1642,22 +1478,19 @@ sbrktest(void)
   c = sbrk(4096);
   if(c != a || sbrk(0) != a + 4096){
     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   if(*lastaddr == 99){
     // should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   a = sbrk(0);
   c = sbrk(-(sbrk(0) - oldbrk));
   if(c != a){
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   // can we read the kernel's memory?
@@ -1666,24 +1499,21 @@ sbrktest(void)
     pid = fork();
     if(pid < 0){
       printf(stdout, "fork failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     if(pid == 0){
       printf(stdout, "oops could read %x = %x\n", a, *a);
       kill(ppid);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
-    wait(0);
+    wait();
   }
 
   // if we run the system out of memory, does it clean up the last
   // failed allocation?
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if((pids[i] = fork()) == 0){
@@ -1703,12 +1533,11 @@ sbrktest(void)
     if(pids[i] == -1)
       continue;
     kill(pids[i]);
-    wait(0);
+    wait();
   }
   if(c == (char*)0xffffffff){
     printf(stdout, "failed sbrk leaked memory\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   if(sbrk(0) > oldbrk)
@@ -1743,19 +1572,17 @@ validatetest(void)
     if((pid = fork()) == 0){
       // try to crash the kernel by passing in a badly placed integer
       validateint((int*)p);
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
     sleep(0);
     sleep(0);
     kill(pid);
-    wait(0);
+    wait();
 
     // try to crash the kernel by passing in a bad string pointer
     if(link("nosuchfile", (char*)p) != -1){
       printf(stdout, "link should not succeed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
 
@@ -1773,8 +1600,7 @@ bsstest(void)
   for(i = 0; i < sizeof(uninit); i++){
     if(uninit[i] != '\0'){
       printf(stdout, "bss test failed\n");
-      //modified exit() to pass in a 1, for error
-      exit(1);
+      exit();
     }
   }
   printf(stdout, "bss test ok\n");
@@ -1801,19 +1627,16 @@ bigargtest(void)
     printf(stdout, "bigarg test ok\n");
     fd = open("bigarg-ok", O_CREATE);
     close(fd);
-    //modified exit() to pass in a 0, for no error
-    exit(0);
+    exit();
   } else if(pid < 0){
     printf(stdout, "bigargtest: fork failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
-  wait(0);
+  wait();
   fd = open("bigarg-ok", 0);
   if(fd < 0){
     printf(stdout, "bigarg test failed!\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(fd);
   unlink("bigarg-ok");
@@ -1892,14 +1715,12 @@ uio()
     port = RTC_DATA;
     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
     printf(1, "uio: uio succeeded; test FAILED\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   } else if(pid < 0){
     printf (1, "fork failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
-  wait(0);
+  wait();
   printf(1, "uio test done\n");
 }
 
@@ -1909,8 +1730,7 @@ void argptest()
   fd = open("init", O_RDONLY);
   if (fd < 0) {
     printf(2, "open failed\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   read(fd, sbrk(0) - 1, -1);
   close(fd);
@@ -1932,8 +1752,7 @@ main(int argc, char *argv[])
 
   if(open("usertests.ran", 0) >= 0){
     printf(1, "already ran user tests -- rebuild fs.img\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   close(open("usertests.ran", O_CREATE));
 
@@ -1980,6 +1799,5 @@ main(int argc, char *argv[])
 
   exectest();
 
-  //modified exit() to pass in a 0, for no error
-  exit(0);
+  exit();
 }
diff --git a/usys.S b/usys.S
index 024b71a..8bfd8a1 100644
--- a/usys.S
+++ b/usys.S
@@ -29,4 +29,3 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
-SYSCALL(waitpid)
diff --git a/wc.c b/wc.c
index 739cc89..d6a54df 100644
--- a/wc.c
+++ b/wc.c
@@ -27,8 +27,7 @@ wc(int fd, char *name)
   }
   if(n < 0){
     printf(1, "wc: read error\n");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
@@ -40,19 +39,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     wc(0, "");
-    //modified exit() to pass in a 1, for error
-    exit(1);
+    exit();
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "wc: cannot open %s\n", argv[i]);
-      //modified exit() to pass in a 1, for error
-    exit(1);
+      exit();
     }
     wc(fd, argv[i]);
     close(fd);
   }
-  //modified exit() to pass in a 0, for no error
-    exit(0);
+  exit();
 }
diff --git a/zombie.c b/zombie.c
index cb980cd..ee817da 100644
--- a/zombie.c
+++ b/zombie.c
@@ -10,6 +10,5 @@ main(void)
 {
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
-  //modified exit() to pass in a 0, for no error
-  exit(0);
+  exit();
 }
